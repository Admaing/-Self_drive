# 第一章：

区块链的组件：

公开的开源的通常包含以下组件

- 点对点网络，用于传播交易和包含已验证交易的区块，基于“gossip”协议
- 状态机中实现的一系列共识规则
- 消息：状态转移
- 状态机
- 分布式数据库，区块链，记录所有状态转移的日志
- 共识算法
- 以上内容的一个或多个开源软件实现

以太坊：参考黄皮书规范，搭建客户端

以太坊图灵完备

**图灵完备：**无法通过在计算机上模拟程序来预测程序是否会终止。

# 第二章 以太坊基础



**世界计算机：** 以太坊上面的高级语言的合约会编译生成EVM字节码



以太坊上面的高级语言的合约会编译生成EVM字节码

合约有一个地址，就像EOAs（钱包）一样。合约可以发送和接收ether，就像钱包一样。当交易目的地是合约地址时，它会导致该合约在EVM中*运行*，并将交易作为其输入。



除了ether之外，交易还可以包含*数据*，用于指示合约中要运行的特定方法以及传递给该方法的参数。通过这种方式，交易通过合约*调用*方法。最后，合约可以产生调用其他合约的交易，建立复杂的执行路径。其中一个典型的用法是合约A调用合约B，以便在合约A的用户之间保持共享状态。

账户的数据结构



## 以太坊货币单位

货币单位：以太**ether**   也叫ETH

以太坊是一种制度，以太是货币

1 ETH = 1*10的18次方 Wei

## 以太坊钱包

拥有用户的密钥，代表用户可以创建和广播交易

助记词可以在其他兼容的钱包恢复资金



## 编译智能合约及其部署

首先创建合约（这里一般直接使用最高版本编译，根据语法更改部分错误）

点击编译，若无其他问题

![image-20211213090156523](%E7%B2%BE%E9%80%9A%E4%BB%A5%E5%A4%AA%E5%9D%8A.assets/image-20211213090156523.png)



![image-20211213090211253](%E7%B2%BE%E9%80%9A%E4%BB%A5%E5%A4%AA%E5%9D%8A.assets/image-20211213090211253.png)

进入运行run&deploy界面

环境许纳泽injected web3

metamask**选择测试网络** kovan，（第二个测试网络无法获取以太）

账户通过自动连接选择第一个



点击部署，等待测试网络挖矿的一段时间，会显示

![image-20211213090348274](%E7%B2%BE%E9%80%9A%E4%BB%A5%E5%A4%AA%E5%9D%8A.assets/image-20211213090348274.png)



- 可以在浏览器中，查看交易，可以使用metamask向智能合约发送交易，交易会判断该地址为合约地址，然后判定该交易为合约交互
- 还可以通过remix中的withdraw向合约发送提取余额的请求



# 第三章



## 以太坊客户端

实现以太坊规范并通过P2P网络与其他以太坊客户端进行通信的软件应用程序。



## 是否应该运行完整节点

完整节点超过80G



## 本地实例的优点和缺点TestRPC



RPC:远程过程调用协议



![img](%E7%B2%BE%E9%80%9A%E4%BB%A5%E5%A4%AA%E5%9D%8A.assets/263.png)

可以用下面图片表示

![image-20211213094756251](%E7%B2%BE%E9%80%9A%E4%BB%A5%E5%A4%AA%E5%9D%8A.assets/image-20211213094756251.png)

以太坊完整节点的大小







# 第五章 密钥地址

椭圆曲线密码术是以太坊数字密钥和数字签名的基础

![image-20211214081447960](%E7%B2%BE%E9%80%9A%E4%BB%A5%E5%A4%AA%E5%9D%8A.assets/image-20211214081447960.png)





为什么使用非对称加密技术：任何有权访问公钥和交易签名的人都可以使用他们来验证每笔交易的每个签名

## 私钥

随机选取的一个数字

## 从随机数生成私钥

生成密钥的第一步：找到一个安全的熵源或随机源。只要不可预测和不可重复，用于选择该数字的确切方法并不重要。

以太坊使用底层操作系统的随机数生成器生成256位熵（随机性）



## 椭圆曲线密码学解释

比特币和以太坊使用的是完全相同的椭圆曲线，称为secp256k1

## 公钥

以太坊公钥是椭圆曲线上的点point，他是一组满满足椭圆曲线方程的X和Y坐标

以太坊是两个数字，并联在一起。通过一次单向的计算从私钥中生成。（可以通过私钥计算公钥，反之不成立，根据椭圆曲线的难题）

## 以太坊的加密哈希函数- Keccak-256

由于Ethereum中使用的哈希函数（Keccak-256）与最终标准（FIP-202 SHA-3）之间的差异造成了混淆，因此正在努力将代码中所有的 sha3 的所有实例，操作码和库重新命名为 keccak256。详情请参阅https://github.com/ethereum/EIPs/issues/59[ERC-59]。

如何判断你使用的软件库是FIPS-202 SHA-3还是Keccak-256（如果两者都可能被称为“SHA3”）？

一个简单的方法是使用*test vector*，一个给定输入的预期输出。最常用于哈希函数的测试是*empty input*。如果你使用空字符串作为输入运行哈希函数，你应该看到以下结果：

Testing whether the SHA3 library you are using is Keccak-256 of FIP-202 SHA-3

```
Keccak256("") =
c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470

SHA3("") =
a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a
```

因此，无论调用什么函数，都可以通过运行上面的简单测试来测试它是否是原始的Keccak-256或最终的NIST标准FIPS-202 SHA-3。请记住，以太坊使用Keccak-256，尽管它在代码中通常被称为SHA-3。

接下来，让我们来看一下Ethereum中Keccak-256的第一个应用，即从公钥生成以太坊地址。



## 生成一个公钥：

使用随机生成的数字k的私钥，将其乘以椭圆曲线上的生成元，得到椭圆曲线上的另一个点，即为相应的公钥



## 以太坊地址

使用单向哈希函数(Keccak-256)从公钥或者合约中派生的

保留最后20个字节

0xa92b28532EC6Bc1ab82ee35D4e420CE86b89a9B5



# 第六章 钱包

## 钱包技术概览

以太坊钱包不包含ether或者代币，只包含密钥。金币等只记录在以太坊区块链中

keystore格式使用*Key派生函数（KDF）*

比特币的BIP-32标准定义的HD钱包

![HD wallet](%E7%B2%BE%E9%80%9A%E4%BB%A5%E5%A4%AA%E5%9D%8A.assets/hd_wallet-16405650492352.png)

## 种子和助记词(BIP-39)

生成助记词流程：

BIP-39中定义的标准化流程自动生成：

1.创建一个128到256的随机序列（熵）

2.取其SHA256哈希的第一部分（熵长度/32）创建随机序列的校验和

3.将这个校验和添加到随机序列的末尾

4.将序列按照11 bits划分

5.将每个11bits的值映射到预定义字典2048个词中的一个，

6.助记词就是单词的序列

![Generating entropy and encoding as mnemonic words](%E7%B2%BE%E9%80%9A%E4%BB%A5%E5%A4%AA%E5%9D%8A.assets/bip39-part1-16405671643694.png)

PBKDF2





----   ***略***



# 第七章 交易



